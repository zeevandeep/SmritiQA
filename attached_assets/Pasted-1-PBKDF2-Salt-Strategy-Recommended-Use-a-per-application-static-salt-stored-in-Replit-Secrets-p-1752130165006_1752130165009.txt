1. PBKDF2 Salt Strategy
‚úÖ Recommended: Use a per-application static salt stored in Replit Secrets

python
Copy
Edit
salt = os.environ.get("STATIC_ENCRYPTION_SALT").encode()
key = PBKDF2(master_key.encode(), salt + user_id.encode(), dkLen=32, count=100_000)
üîé Why not per-user salt?
Per-user salts require storage in the DB (users.salt) and complicate key derivation during runtime.

They are only useful if you're also storing unique keys per user (which you're not‚Äîyou're deriving from master + ID).

Since you're deriving keys from a master key, a global static salt is sufficient, as long as it's long and secret (e.g., 16+ bytes of random data).

‚úÖ Simpler, deterministic, and secure enough for your design.

2. Migration Rollback Strategy
‚úÖ Recommended: Continue on error but log + isolate failures

Suggested behavior:

Skip record if decryption fails

Log full context (user_id, session_id, timestamp, error type)

Insert the failed record into a separate migration_errors table for review

sql
Copy
Edit
CREATE TABLE migration_errors (
  id UUID PRIMARY KEY,
  user_id UUID,
  session_id UUID,
  error_type TEXT,
  error_message TEXT,
  created_at TIMESTAMP DEFAULT now()
);
üîê This avoids losing all progress due to one corrupted session, and gives you visibility for manual fix/migration later.

3. Encryption Failure Logging
‚úÖ Recommended: Hybrid strategy for now, audit trail later

Start with:

log
Copy
Edit
[ERROR] Decryption failed for user_id=abc123, session_id=xyz456 - InvalidToken
If you're handling security incidents or GDPR compliance in the future:

Add timestamp, operation (decrypt, encrypt), origin (api, migration, etc.)

Output to dedicated security logs (S3, logging service, etc.)

For now:

python
Copy
Edit
logger.error(f"[ENCRYPTION FAIL] op=decrypt user_id={user_id} session_id={session_id} error={e}")
‚ö†Ô∏è Avoid logging actual encrypted data or keys.

4. Scope of Encryption
‚úÖ Recommended: Three-phase rollout

Phase	Table	Rationale
1	sessions.raw_transcript	User input ‚Äì most sensitive
2	nodes.text	Derived from user input ‚Äì sensitive but not raw
3	reflections.generated_text	Echoes thoughts ‚Äì semi-sensitive

Why phase it?

Keeps risk low and testing focused

Let you harden repository encryption logic in phase 1

Gives you time to build decrypt-on-demand for UI and API for nodes and reflections

5. Environment Variable Strategy (Replit Secrets)
‚úÖ Recommended: Keep them separate, clear, and long

bash
Copy
Edit
MASTER_ENCRYPTION_KEY = "base64-encoded-32-byte-secret"
STATIC_ENCRYPTION_SALT = "base64-encoded-16-byte-salt"
Naming Convention Best Practice:
Use full uppercase and clear names

Avoid ambiguous names like ENCRYPTION_KEY (too generic)

Example secret names:

MASTER_ENCRYPTION_KEY

STATIC_ENCRYPTION_SALT

